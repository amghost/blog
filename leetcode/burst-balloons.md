# 一个TLE的思路
问题一看就是一个最优化问题，思路就朝着DP去了。乍一看很简单，每次选出一个要burst的balloon，得到一个子序列，解决这个子序列就是解决一个类型相同只不过规模小一点的子问题，而且不难发现有些子问题是会被多次求解的，很符合DP能够解决的问题类型，没毛病。

以`[3, 1, 5, 8]`为例，其解：
```
P([3,1,5,8]) = max{Q(3)+P([1,5,8]) , Q(1)+P([3,5,8]), Q(5)+P([3,1,8]), Q(8)+P([3,1,5])};
```
其中，P为对特定序列的解，Q为在当前序列下burst指定balloon得到的coins。

问题就变成求解这些子序列

但是这种解法遇到的第一个问题就是：**如何表示一个子序列，以便利用memoization检索避免重复计算？**，使用两个下标分别表示起始和结束是不行的，因为在每次选中一个balloon时，其两端的序列会拼接起来成为我们要解决的子序列，这些子序列原本并不是连续的。于是索性我直接将序列hash后结合`unordered_map`来做，这虽然相比直接用`vector<int>`作为map的key高效得多（用perf统计了一下，减少了很多vector的比较，总体耗时下降了30%），然而依然不能解决耗时太长的问题（在leetcode平台跑花了500~600ms）, 因为我们枚举了几乎全部的原序组合，每次都需要拼接新的子序列导致了非常多的内存copy操作。

虽然可以得到正确的结果，但是算法复杂度是高得无法接受的。

# 反向思维
个人认为，问题的核心是拆分子结构的时候同时引入了计算复杂度，甚至可以说直接拼接左右子序列为一个新的子序列本身并不是合理的子结构模型，可能在排序上它保持了和原序列相同，但是穿插组合也使得其于原序列相去甚远了，这也直接导致我们对子结构表达起来困难重重。

但是如果反向思考一下，能否从最后一个burst的balloon入手呢？想想这样做会怎样？

对于一个序列中（不论是原始序列，还是任意一个子序列，子序列的选取下面说）最后一个burst的balloon，其两边的子序列是**独立的**。

独立是什么意思呢？假设对于序列S

`{S1} b {S2}`

b为序列S在最优条件下最后一个burst的，S1为b左边的子序列，S2为b右边的子序列。因为b是最后一个burst的，所以不存在S1和S2拼接在一起的可能性。所以对于S而言，S1和S2为两个独立的子结构，而且关键的是它们相对于原问题序列也是连续的子序列。此时我们的状态转移方程变成了：

`P(S) = max{ P(S1)+Q'(b)+P(S2) }, b ∈ S`

理解这个还有几点需要叙述：

`Q'(b)`不再是`nums[b-1] * nums[b] * nums[b+1]`。因为b是对于序列S最后一个burst的，而不是当前要burst的，当b本身的分值被count的时候，应该是乘上序列S的最右边-1，以及最左边+1的在原序列上的元素。

还是以`[3, 1, 5, 8]`为例，对于子序列S `[1, 5]`，假设5是其最后一个burst的，那么应该是 `3 * 5 * 8`，理解这个要谨记我们现在是一个**反向推导**的过程。这也解释了为什么S1和S2的解很重要。因为在正向流程里，我们是先解决了S1和S2后再来解决b的，而且我们说了，S1和S2是独立互不影响的，因为各自在b的两边。当我们解决b的时候序列S中所有的元素都被干掉了。

最后用题目中很简单的一个例子来说明，正向的解决流程是这样的（上帝视角，最优解）
```
nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```
`8`是最后一个burst的，我们首先要解决其左边的`[3,1,5]`以及右边的`[]`，解决的顺序可能是交叉无序的，因为各自独立，轮到`8`时，自然就是`1 * 8 * 1`。

对于`[3,1,5]`，`3`是最后一个burst的，首先要解决其左边的`[]`和`[1,5]`，轮到`3`时就是`1 * 3 * 8`

对于`[1,5]`，`5`是最后一个burst的，首先要解决其左边的`[1]`以及`[]`，轮到`5`时就是`3 * 5 * 8`

对于`[1]`，`1`是最后一个也是唯一一个burst的，得到的coins是`3 * 1 * 5`

See? 对每个子序列的求解，子序列的两端（用C++ iterator表达就是`S.begin() -1`和`S.end()`）是相关的。

# Code
```cpp
// DP, Bottom-Up
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        size_t N = nums.size();
        nums.insert(nums.begin(), 1);
        nums.insert(nums.end(), 1);

        vector<vector<int>> record(nums.size(), vector<int>(nums.size(), 0));

        for (size_t len = 1; len <= N; len++ ) {
            size_t bound = N - len + 1;
            for (size_t start = 1; start <= bound; start++) {
                size_t end = start + len - 1;
                int tmp_max = -1;
                for (size_t i = start; i <= end; i++) {
                    int point = nums[start -1]*nums[i]*nums[end+1] +
                        record[start][i-1] + record[i+1][end];
                    tmp_max = tmp_max > point ? tmp_max : point;
                }
                record[start][end] = tmp_max;
            }
        }
        return record[1][N];
    }

};
```

# 总结
这道题个人感觉还是有点难度的。乍一看是简单的DP解法，实际上却埋了坑在里头，可能运用DP思想还要根据要解决的实际问题具体问题具体分析。

反向思维是分治、动态规划的思想基础。从最小的问题开始解决，最后合并子问题解得到原问题解。这道题更进一层，要求我们用反向思维来分析问题，值得学习。

动态规划需要很好地定义子结构，子结构定义不好、表达困难，动态规划运用起来就比较难。对于序列，能够直接用起始下标和结束下标两个量来表述子结构恐怕是最好的，这也意味这子结构序列必须是相对原问题序列是连续的。





